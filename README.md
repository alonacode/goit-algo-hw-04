# Порівняння алгоритмів сортування: вставки, злиття та Timsort

**Мета:** емпірично порівняти алгоритми за часом виконання на різних наборах даних за допомогою `timeit`.

## Набори даних
- `random` — випадкові числа
- `sorted` — вже відсортований масив
- `reversed` — зворотно відсортований
- `nearly_sorted` — майже відсортований (≈1% випадкових перестановок)
- `many_dups` — багато дублікатів (значення з малого діапазону)

## Розміри масивів
`[100, 300, 1000, 3000, 10000]` (для дуже повільних випадків insertion sort може бути пропущено як «skipped»).

## Результати (секунди, менше — краще)
| Dataset | N | Algorithm | min (s) | median (s) | max (s) |
|---|---:|---|---:|---:|---:|
| many_dups | 100 | insertion | 0.000150 | 0.000164 | 0.000184 |
| many_dups | 100 | merge | 0.000138 | 0.000155 | 0.000160 |
| many_dups | 100 | timsort(sorted) | 0.000004 | 0.000004 | 0.000008 |
| many_dups | 300 | insertion | 0.001441 | 0.001457 | 0.001504 |
| many_dups | 300 | merge | 0.000471 | 0.000483 | 0.000491 |
| many_dups | 300 | timsort(sorted) | 0.000015 | 0.000017 | 0.000025 |
| many_dups | 1000 | insertion | 0.018091 | 0.018284 | 0.019147 |
| many_dups | 1000 | merge | 0.001863 | 0.001867 | 0.001896 |
| many_dups | 1000 | timsort(sorted) | 0.000096 | 0.000097 | 0.000105 |
| many_dups | 3000 | insertion | 0.176705 | 0.179053 | 0.183233 |
| many_dups | 3000 | merge | 0.006335 | 0.006481 | 0.007040 |
| many_dups | 3000 | timsort(sorted) | 0.000339 | 0.000359 | 0.000385 |
| many_dups | 10000 | insertion | 2.027254 | 2.067977 | 2.095483 |
| many_dups | 10000 | merge | 0.025056 | 0.025283 | 0.025499 |
| many_dups | 10000 | timsort(sorted) | 0.001162 | 0.001210 | 0.001311 |
| nearly_sorted | 100 | insertion | 0.000017 | 0.000018 | 0.000027 |
| nearly_sorted | 100 | merge | 0.000123 | 0.000125 | 0.000147 |
| nearly_sorted | 100 | timsort(sorted) | 0.000003 | 0.000003 | 0.000004 |
| nearly_sorted | 300 | insertion | 0.000040 | 0.000040 | 0.000042 |
| nearly_sorted | 300 | merge | 0.000390 | 0.000394 | 0.000412 |
| nearly_sorted | 300 | timsort(sorted) | 0.000005 | 0.000005 | 0.000006 |
| nearly_sorted | 1000 | insertion | 0.000620 | 0.000621 | 0.000632 |
| nearly_sorted | 1000 | merge | 0.001549 | 0.001560 | 0.001568 |
| nearly_sorted | 1000 | timsort(sorted) | 0.000019 | 0.000020 | 0.000023 |
| nearly_sorted | 3000 | insertion | 0.004803 | 0.004831 | 0.004885 |
| nearly_sorted | 3000 | merge | 0.005377 | 0.005401 | 0.005468 |
| nearly_sorted | 3000 | timsort(sorted) | 0.000057 | 0.000058 | 0.000069 |
| nearly_sorted | 10000 | insertion | 0.056012 | 0.056824 | 0.060066 |
| nearly_sorted | 10000 | merge | 0.020718 | 0.020974 | 0.021460 |
| nearly_sorted | 10000 | timsort(sorted) | 0.000225 | 0.000251 | 0.000282 |
| random | 100 | insertion | 0.000155 | 0.000166 | 0.000193 |
| random | 100 | merge | 0.000144 | 0.000146 | 0.000174 |
| random | 100 | timsort(sorted) | 0.000005 | 0.000005 | 0.000009 |
| random | 300 | insertion | 0.001450 | 0.001527 | 0.001700 |
| random | 300 | merge | 0.000486 | 0.000487 | 0.000598 |
| random | 300 | timsort(sorted) | 0.000019 | 0.000020 | 0.000029 |
| random | 1000 | insertion | 0.018165 | 0.018467 | 0.020403 |
| random | 1000 | merge | 0.001883 | 0.002028 | 0.002350 |
| random | 1000 | timsort(sorted) | 0.000111 | 0.000116 | 0.000137 |
| random | 3000 | insertion | 0.177537 | 0.187103 | 0.200658 |
| random | 3000 | merge | 0.006356 | 0.006426 | 0.006676 |
| random | 3000 | timsort(sorted) | 0.000391 | 0.000391 | 0.000396 |
| random | 10000 | insertion |  –  |  –  |  –  |
| random | 10000 | merge | 0.024139 | 0.024240 | 0.024265 |
| random | 10000 | timsort(sorted) | 0.001539 | 0.001539 | 0.001563 |
| reversed | 100 | insertion | 0.000318 | 0.000329 | 0.000335 |
| reversed | 100 | merge | 0.000119 | 0.000119 | 0.000122 |
| reversed | 100 | timsort(sorted) | 0.000002 | 0.000002 | 0.000002 |
| reversed | 300 | insertion | 0.002880 | 0.002890 | 0.002904 |
| reversed | 300 | merge | 0.000391 | 0.000391 | 0.000398 |
| reversed | 300 | timsort(sorted) | 0.000003 | 0.000003 | 0.000004 |
| reversed | 1000 | insertion | 0.036271 | 0.036643 | 0.038229 |
| reversed | 1000 | merge | 0.001400 | 0.001415 | 0.001456 |
| reversed | 1000 | timsort(sorted) | 0.000010 | 0.000010 | 0.000011 |
| reversed | 3000 | insertion | 0.346781 | 0.348999 | 0.356494 |
| reversed | 3000 | merge | 0.004665 | 0.004675 | 0.004717 |
| reversed | 3000 | timsort(sorted) | 0.000030 | 0.000030 | 0.000031 |
| reversed | 10000 | insertion |  –  |  –  |  –  |
| reversed | 10000 | merge | 0.017211 | 0.017282 | 0.017461 |
| reversed | 10000 | timsort(sorted) | 0.000107 | 0.000107 | 0.000113 |
| sorted | 100 | insertion | 0.000009 | 0.000009 | 0.000010 |
| sorted | 100 | merge | 0.000113 | 0.000114 | 0.000117 |
| sorted | 100 | timsort(sorted) | 0.000002 | 0.000002 | 0.000002 |
| sorted | 300 | insertion | 0.000027 | 0.000027 | 0.000028 |
| sorted | 300 | merge | 0.000375 | 0.000376 | 0.000388 |
| sorted | 300 | timsort(sorted) | 0.000003 | 0.000003 | 0.000004 |
| sorted | 1000 | insertion | 0.000105 | 0.000106 | 0.000107 |
| sorted | 1000 | merge | 0.001382 | 0.001432 | 0.001477 |
| sorted | 1000 | timsort(sorted) | 0.000010 | 0.000010 | 0.000011 |
| sorted | 3000 | insertion | 0.000318 | 0.000320 | 0.000327 |
| sorted | 3000 | merge | 0.004550 | 0.004562 | 0.004763 |
| sorted | 3000 | timsort(sorted) | 0.000029 | 0.000029 | 0.000030 |
| sorted | 10000 | insertion | 0.001089 | 0.001094 | 0.001212 |
| sorted | 10000 | merge | 0.016596 | 0.016718 | 0.017018 |
| sorted | 10000 | timsort(sorted) | 0.000102 | 0.000103 | 0.000105 |

## Аналіз і висновки
- На великих випадкових масивах **Timsort** і **злиття** суттєво швидші за **вставки**, що відповідає теорії (O(n log n) проти O(n²)).
- На **майже відсортованих даних** Timsort помітно швидший за злиття завдяки використанню природних «runs» та вставок усередині малих підмасивів (лінійна близькість до O(n)).
- На **вже відсортованих** даних Timsort працює майже лінійно (близько до O(n)) завдяки стабільності та детекції вже відсортованих підпослідовностей.
- Для **даних із великою кількістю дублікатів** Timsort також показує відмінні результати через оптимізоване злиття і стабільність.
**Висновок:** гібридність Timsort (поєднання злиття + вставок, детекція природних runs, «галопуюче» злиття) робить його **практично найефективнішим загальним сортуванням** у Python, тому розробники у більшості випадків використовують **вбудований `sorted`/`.sort()`**, а не пишуть власні реалізації.

### Теоретичні очікування
- **Insertion sort**: O(n²) у середньому/гіршому; дуже швидкий на дуже малих масивах або майже відсортованих.
- **Merge sort**: O(n log n) завжди; стабільний, але потребує додаткову памʼять.
- **Timsort (sorted)**: гібрид злиття та вставок + детекція «runs», оптимізоване злиття (включно з «галопуванням»). У найкращих для нього випадках близький до O(n), загалом змагально-швидкий на реальних даних.

> Саме завдяки цим властивостям **Timsort** у Python є дефолтним і зазвичай **істотно ефективніший** за «чисті» класичні реалізації, тому програмісти використовують **вбудовані** `sorted`/`.sort()`.
